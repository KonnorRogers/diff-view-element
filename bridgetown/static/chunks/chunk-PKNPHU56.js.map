{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/validators/too-long-validator.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/validators/too-short-validator.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/validators/value-missing-validator.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/mixins/custom-states-mixin.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/mixins/form-associated-mixin.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/mixins/vanilla-form-associated-mixin.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/mixins/lit-form-associated-mixin.js", "../../../../node_modules/.pnpm/form-associated-helpers@0.0.10/node_modules/form-associated-helpers/exports/mixins/lit-textarea-mixin.js", "../../../../node_modules/.pnpm/light-pen@4.1.0/node_modules/light-pen/exports/components/light-editor/light-editor.styles.js", "../../../../node_modules/.pnpm/light-pen@4.1.0/node_modules/light-pen/internal/base-event.js", "../../../../node_modules/.pnpm/light-pen@4.1.0/node_modules/light-pen/exports/events/light-resize-event.js", "../../../../node_modules/.pnpm/light-pen@4.1.0/node_modules/light-pen/exports/components/light-editor/light-editor.js"],
  "sourcesContent": ["/**\n * @typedef {import(\"../types.js\").FormValue} FormValue\n */\n\n/**\n * @template {HTMLElement & { maxLength?: number, value: FormValue }} [T=(HTMLElement & { maxLength?: number, value: FormValue })]\n */\nexport const TooLongValidator = () => {\n  const obj = {\n    observedAttributes: [\"maxlength\"],\n    /**\n     * @param {T} _hostElement\n     * @param {number} maxLength\n     * @param {number} stringLength\n     */\n    message (_hostElement, maxLength, stringLength) {\n      // @TODO: This is an edge case with maxlength. minlength has the same issue.\n      // const maxLength = Number(element.maxLength || element.getAttribute(\"maxlength\"))\n      // const value = element.value\n      // const badInput = Object.assign(document.createElement(\"input\"), {\n      //   value,\n      //   maxLength\n      // })\n\n      // return badInput.validationMessage\n      return `Please shorten this text to ${maxLength} characters or less. (You are currently using ${stringLength} characters).`\n    },\n    /**\n     * @param {T} element\n     */\n    checkValidity (element) {\n      /**\n      * @type {ReturnType<import(\"../types.js\").Validator[\"checkValidity\"]>}\n      */\n      const validity = {\n        message: \"\",\n        isValid: true,\n        invalidKeys: []\n      }\n\n      /** if its not a string, we really can't compare. */\n      let value = element.value ?? \"\"\n      if (typeof value !== \"string\") { return validity }\n\n      const maxLength = Number(element.maxLength ?? element.getAttribute(\"maxlength\"))\n\n      if (isNaN(maxLength) || maxLength == null || maxLength <= 0) { return validity }\n\n      if (value.length > maxLength) {\n        validity.message = (typeof obj.message === \"function\" ? obj.message(element, maxLength, value.length) : obj.message) || \"\"\n        validity.isValid = false\n        validity.invalidKeys.push(\"tooLong\")\n      }\n\n      return validity;\n    }\n  }\n\n  return obj\n}\n\n", "/**\n * @typedef {import(\"../types.js\")} FormValue\n */\n\n/**\n * @template {HTMLElement & { minLength?: number, value: FormValue }} [T=(HTMLElement & { minLength?: number, value: FormValue })]\n */\nexport const TooShortValidator = () => {\n  const obj = {\n    observedAttributes: [\"minlength\"],\n    /**\n     * @param {T} _hostElement\n     * @param {number} minLength\n     * @param {number} stringLength\n     */\n    message (_hostElement, minLength, stringLength) {\n      // @TODO: This is an edge case with minlength. maxlength has the same issue.\n      // const maxLength = Number(element.minLength || element.getAttribute(\"minlength\"))\n      // const value = element.value\n      // const badInput = Object.assign(document.createElement(\"input\"), {\n      //   value,\n      //   maxLength\n      // })\n\n      // return badInput.validationMessage\n      return `Please lengthen this text to ${minLength} characters or more. (You are currently using ${stringLength} characters).`\n    },\n    /**\n     * @param {T} element\n     */\n    checkValidity (element) {\n      /**\n      * @type {ReturnType<import(\"../types.js\").Validator[\"checkValidity\"]>}\n      */\n      const validity = {\n        message: \"\",\n        isValid: true,\n        invalidKeys: []\n      }\n\n      /** if its not a string, we really can't compare. */\n      let value = element.value ?? \"\"\n      if (typeof value !== \"string\") { return validity }\n\n      const minLength = Number(element.minLength || element.getAttribute(\"minlength\"))\n\n      if (isNaN(minLength) || minLength == null || minLength <= 0) { return validity }\n\n      if (value.length < minLength) {\n        validity.message = (typeof obj.message === \"function\" ? obj.message(element, minLength, value.length) : obj.message) || \"\"\n        validity.isValid = false\n        validity.invalidKeys.push(\"tooShort\")\n      }\n\n      return validity;\n    }\n  }\n\n  return obj\n}\n", "/**\n * @typedef {{validationMessage: string }} Validateable\n */\n\n/**\n * @type {() => import(\"../types.js\").Validator<HTMLElement & { required?: boolean }>}\n */\nexport const ValueMissingValidator = () => {\n  /**\n   * @type {ReturnType<ValueMissingValidator>}\n   */\n  const obj = {\n    observedAttributes: [\"required\"],\n    message: Object.assign(document.createElement(\"input\"), {\n      required: true,\n    }).validationMessage,\n    checkValidity (element) {\n      /**\n      * @type {ReturnType<import(\"../types.js\").Validator[\"checkValidity\"]>}\n      */\n      const validity = {\n        message: \"\",\n        isValid: true,\n        invalidKeys: []\n      }\n\n      const isRequired = element.required ?? element.hasAttribute(\"required\")\n\n      // Always true if the element isn't required.\n      if (!isRequired) {\n        return validity\n      }\n\n      if (!element.value) {\n        validity.message = (typeof obj.message === \"function\" ? obj.message(element) : obj.message) || \"\"\n        validity.isValid = false\n        validity.invalidKeys.push(\"valueMissing\")\n      }\n\n      return validity\n    }\n  }\n\n  return obj\n}\n\n", "/**\n * @typedef {import(\"./types.js\").GConstructable<HTMLElement & { internals: ElementInternals }> & { observedAttributes?: string[] }} ElementInternalsElement\n */\n\n/**\n * A mixin for using custom states without calling `this.internals.add()`\n * @template {ElementInternalsElement} T\n * @param {T} superclass\n */\nexport function CustomStatesMixin(superclass) {\n  return (\n    class extends superclass {\n      /**\n       * @param {string} state\n       */\n      addCustomState (state) {\n        try {\n          this.internals.states.add(state)\n        } catch (_) {\n          // Without this, test suite errors.\n        } finally {\n          this.setAttribute(`data-${state}`, \"\")\n        }\n      }\n\n      /**\n       * @param {string} state\n       */\n      deleteCustomState (state) {\n        try {\n          this.internals.states.delete(state)\n        } catch (_) {\n          // Without this, test suite errors.\n        } finally {\n          this.removeAttribute(`data-${state}`)\n        }\n      }\n\n      /**\n       * @param {string} state\n       * @param {boolean} bool\n       */\n      toggleCustomState (state, bool) {\n        if (bool === true) {\n          this.addCustomState(state)\n          return\n        }\n\n        if (bool === false) {\n          this.deleteCustomState(state)\n          return\n        }\n\n        this.toggleCustomState(state, !this.hasCustomState(state))\n      }\n\n      /**\n       * @param {string} state\n       * @returns {boolean}\n       */\n      hasCustomState (state) {\n        try {\n          return this.internals.states.has(state)\n        } catch (_) {\n          // Without this, test suite errors.\n        } finally {\n          return this.hasAttribute(`data-${state}`)\n        }\n      }\n    }\n  )\n}\n\n", "/**\n * Global type to add ElementInternals.states\n * Can go away when TS ships proper support.\n * @type {import(\"../../types/index.d.ts\")}\n */\n\n/**\n * A mixin to call `attachInternals()`\n * This is merely an implementation that sets the `formAssociated` static class property and calls `attachInternals()`. It doesn't do anything else. It is intentionally minimal.\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {import(\"./types.js\").GConstructable<HTMLElement> & {observedAttributes?: string[], formAssociated?: boolean}} T\n * @param {T} superclass\n */\nexport function FormAssociatedMixin(superclass) {\n  return (\n    /**\n     */\n    class extends superclass {\n      static formAssociated = superclass.formAssociated ?? true\n\n      /**\n      * @param {...any} args\n      */\n      constructor(...args) {\n        super(...args)\n\n        /**\n        * We dont make it private like #internals because then its not available in the mixin.\n        * @type {ReturnType<HTMLElement[\"attachInternals\"]>}\n        */\n        this.internals\n\n        if (!this.internals) {\n          this.internals = this.attachInternals()\n        }\n      }\n    }\n  )\n}\n", "import { ValueMissingValidator } from \"../validators/value-missing-validator.js\"\nimport { CustomStatesMixin } from \"./custom-states-mixin.js\"\nimport { FormAssociatedMixin } from \"./form-associated-mixin.js\"\n\n/**\n * @typedef {import(\"./types.js\").GConstructable<HTMLElement & Partial<{ formControl?: null | undefined | (HTMLElement & { value: any, defaultValue: any })}>> & { observedAttributes?: string[] }} FormAssociatedElement\n */\n\n/**\n * @param {HTMLElement & { disabled: boolean }} el\n */\nfunction isDisabled (el) {\n  return Boolean(el.matches(\":disabled\") || el.disabled)\n}\n\n/**\n * A mixin of form associated helpers that get added to a class with attachInternals.\n * This opinionated version extends the above formAssociated and handles common conventions I like.\n * Required properties: { value, disabled, formControl, validationTarget }\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {FormAssociatedElement} T\n * @param {T} superclass\n */\nexport function VanillaFormAssociatedMixin(superclass) {\n  return (\n    class extends CustomStatesMixin(FormAssociatedMixin(superclass)) {\n      /**\n       * @override\n       */\n      static get observedAttributes () {\n        const parentAttrs = new Set(/** @type {string[]} */ (super.observedAttributes) || [])\n\n        for (const validator of this.validators) {\n          if (!validator.observedAttributes) { continue }\n\n          for (const attr of validator.observedAttributes) {\n            parentAttrs.add(attr)\n          }\n        }\n\n        return [...parentAttrs]\n      }\n\n\n      /**\n       * Validators are static because they have `observedAttributes`, essentially attributes to \"watch\"\n       * for changes. Whenever these attributes change, we want to be notified and update the validator.\n       * @type {Array<import(\"../types.js\").Validator>}\n       */\n      static get validators () {\n        return [\n          ValueMissingValidator()\n        ]\n      }\n\n      /**\n       * @param {...any} args\n       */\n      constructor (...args) {\n        super(...args)\n\n        /**\n         * @type {ElementInternals[\"role\"]}\n         */\n        this.role = this.getAttribute(\"role\") || null\n\n        /**\n         * @type {FormData | string | File | null}\n         */\n        this.value = this.getAttribute(\"value\") || null\n\n        /**\n         * @type {FormData | string | File | null}\n         */\n        this.previousValue = this.value\n\n        /**\n         * @type {null | string}\n         */\n        this.defaultValue = this.getAttribute(\"value\") || null\n\n        /**\n         * @type {HTMLInputElement[\"name\"]}\n         */\n        this.name = this.getAttribute(\"name\") || \"\"\n\n        /**\n         * `this.type` is used by ElementInternals.\n         * @type {string}\n         */\n        this.type = this.getAttribute(\"type\") || this.localName || \"\"\n\n        /**\n         * Make sure if you're using a library that \"reflects\" properties to attributes, you don't reflect this `disabled.`\n         * @type {boolean}\n         */\n        this.disabled = isDisabled(this)\n\n        /**\n         * Generally forms can have \"required\", this may not be necessary here, but is a nice convention.\n         * @type {boolean}\n         */\n        this.required = this.hasAttribute(\"required\")\n\n        /**\n         * Tracks when a user blurs from a form control.\n         * @type {boolean}\n         */\n        this.hasInteracted = this.hasInteracted ?? false\n\n        /**\n         * Dirty tracks if the value has been changed.\n         * @type {boolean}\n         */\n        this.valueHasChanged = this.valueHasChanged ?? false\n\n        /**\n         * While not generally encouraged, you can add instance level validators.\n         *   These validators should not rely on an attribute, or should already have a \"watched\" attribute\n         *   to know when to re-run the validator.\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        this.validators = []\n\n        // this.setFormValue(null)\n\n        // this.addEventListener(\"focusin\", this.handleInteraction)\n        this.addEventListener(\"focusout\", this.handleInteraction)\n        this.addEventListener(\"blur\", this.handleInteraction)\n        this.addEventListener(\"invalid\", this.handleInvalid)\n\n        // Private\n\n        /** This is a dirty check for custom errors. In Safari, {customError: true} always happens with `setValidity()`. This is the workaround. */\n        this.__hasCustomError = false\n        this.__customErrorMessage = \"\"\n      }\n\n      /**\n       * @param {Event} e\n       */\n      handleInvalid = (e) => {\n        if (e.target !== this) return\n        if (isDisabled(this)) return\n\n        if (this.value !== this.defaultValue) {\n          this.valueHasChanged = true\n        }\n\n        this.hasInteracted = true\n\n        this.updateInteractionState()\n      }\n\n      /**\n       * Sets `this.hasInteracted = true` to true when the users focus / clicks the element.\n       * @param {Event} e\n       */\n      handleInteraction = (e) => {\n        if (isDisabled(this)) return\n\n        if (!this.matches(\":focus-within\") && this.valueHasChanged) {\n          this.hasInteracted = true\n        }\n        this.updateValidity()\n      }\n\n      get allValidators () {\n        /**\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        // @ts-expect-error\n        const staticValidators = this.constructor.validators || []\n\n        /**\n         * @type {Array<import(\"../types.js\").Validator>}\n         */\n        const validators = this.validators || []\n        return [...staticValidators, ...validators]\n      }\n\n      get willShowValidationMessage () {\n        return (isDisabled(this)) && this.hasInteracted === true\n      }\n\n      get labels () {\n        return /** @type {NodeListOf<HTMLLabelElement>} */ (this.internals.labels)\n      }\n\n      get validity () {\n        return this.internals.validity\n      }\n\n      get validationMessage () {\n        return this.internals.validationMessage\n      }\n\n      get willValidate () {\n        return this.internals.willValidate\n      }\n\n      /**\n       * This function technically does not exist with internals, but exists on native form elements.\n       *   This is backported for users familiar with the API.\n       * @param {string} message\n       */\n      setCustomValidity (message) {\n        if (!message) {\n          this.__hasCustomError = false\n          this.__customErrorMessage = \"\"\n          this.setValidity({})\n          return\n        }\n\n        this.__hasCustomError = true\n        this.__customErrorMessage = message\n        this.internals.setValidity({customError: true}, message)\n      }\n\n      /**\n       * @param {string} name\n       * @param {string} oldVal\n       * @param {string} newVal\n       */\n      attributeChangedCallback(name, oldVal, newVal) {\n        // @ts-expect-error\n        if (typeof super.attributeChangedCallback === \"function\") {\n          // @ts-expect-error\n          super.attributeChangedCallback(name, oldVal, newVal)\n        }\n\n        if (newVal === oldVal) {\n          return\n        }\n\n        if (name === \"role\") {\n          this.internals.role = newVal || null\n        }\n\n        if (name === \"value\") {\n          this.defaultValue = newVal\n\n          if (!this.hasInteracted && !this.valueHasChanged) {\n            this.value = this.defaultValue\n            this.setFormValue(this.value, this.value)\n          }\n        }\n\n        if (name === \"disabled\") {\n          this.disabled = Boolean(newVal)\n        }\n\n        this.updateValidity()\n      }\n\n      /**\n      * Called when the form is being reset. (e.g. user pressed `<input[type=reset]>` button). Custom element should clear whatever value set by the user.\n      * @returns {void}\n      */\n      formResetCallback() {\n        if (\"formControl\" in this && this.formControl) {\n          this.formControl.value = this.defaultValue\n        }\n\n        this.resetValidity()\n        this.value = this.defaultValue\n        this.hasInteracted = false\n        this.valueHasChanged = false\n        this.updateValidity()\n        this.setFormValue(this.defaultValue, this.defaultValue)\n      }\n\n      /**\n      * Called when the disabled state of the form changes\n      * @param {boolean} isDisabled\n      * @returns {void}\n      */\n      formDisabledCallback(isDisabled) {\n        this.disabled = isDisabled\n        this.resetValidity()\n        this.updateValidity()\n      }\n\n      /**\n      * Called when the browser is trying to restore element\u2019s state to state in which case reason is \u201Crestore\u201D, or when the browser is trying to fulfill autofill on behalf of user in which case reason is \u201Cautocomplete\u201D. In the case of \u201Crestore\u201D, state is a string, File, or FormData object previously set as the second argument to setFormValue.\n      * @param {string | File | FormData | null} state\n      * @param {string} reason\n      * @returns {void}\n      */\n      formStateRestoreCallback(state, reason) {\n        this.value = state\n\n        if (this.formControl) {\n          this.formControl.value = state\n        }\n\n        this.resetValidity()\n        this.updateValidity()\n\n      }\n\n      // Additional things not added by the `attachInternals()` call.\n\n      /**\n       * This should generally not be used by end users. This is intended for custom validators.\n       * @param {Parameters<ElementInternals[\"setValidity\"]>} params\n       */\n      setValidity (...params) {\n        let flags = params[0]\n        let message = params[1]\n\n        let anchor = params[2]\n\n        if (!anchor) {\n          const validationTarget = this.validationTarget\n          anchor = validationTarget\n        }\n\n        this.internals.setValidity(flags, message, anchor)\n        this.updateInteractionState()\n      }\n\n      reportValidity () {\n        this.updateValidity()\n        return this.internals.reportValidity()\n      }\n\n      checkValidity () {\n        this.updateValidity()\n        return this.internals.checkValidity()\n      }\n\n      /**\n        * `validationTarget` is used for displaying native validation popups as the \"anchor\"\n        * @type {undefined | HTMLElement}\n        */\n      get validationTarget () {\n        return this.formControl || undefined\n      }\n\n      /**\n        * @param {Parameters<ElementInternals[\"setFormValue\"]>} args\n        */\n      setFormValue (...args) {\n        // Dirty tracking of values.\n        if (this.value !== this.defaultValue) {\n          this.valueHasChanged = true\n        }\n\n        this.internals.setFormValue(...args)\n        this.updateValidity()\n      }\n\n      /**\n       * Returns the form attached to the element\n       * @returns {ReturnType<ElementInternals[\"form\"]>}\n       */\n      get form () {\n        return this.internals.form\n      }\n\n      resetValidity () {\n        this.setCustomValidity(\"\")\n        this.setValidity({})\n      }\n\n      updateValidity () {\n        if (isDisabled(this)) {\n          this.resetValidity()\n          // We don't run validators on disabled thiss to be inline with native HTMLElements.\n          // https://codepen.io/paramagicdev/pen/PoLogeL\n          return\n        }\n\n        const validators = /** @type {{allValidators?: Array<import(\"../types.js\").Validator>}} */ (/** @type {unknown} */ (this)).allValidators\n\n        if (!validators) {\n          this.setValidity({})\n          return\n        }\n\n        const customError = Boolean(this.__hasCustomError)\n        const flags = {\n          customError\n        }\n\n        const formControl = this.formControl || undefined\n\n        let finalMessage = \"\"\n\n        for (const validator of validators) {\n          const { isValid, message, invalidKeys } = validator.checkValidity(this)\n\n          if (isValid) { continue }\n\n          if (!finalMessage) {\n            finalMessage = message\n          }\n\n          if (invalidKeys?.length >= 0) {\n            // @ts-expect-error\n            invalidKeys.forEach((str) => flags[str] = true)\n          }\n        }\n\n        // This is a workaround for preserving custom errors\n        if (!finalMessage) {\n          finalMessage = this.validationMessage || this.__customErrorMessage\n        }\n\n        this.setValidity(flags, finalMessage, formControl)\n      }\n\n      updateInteractionState () {\n        if (isDisabled(this)) {\n          this.addCustomState(\"disabled\")\n          this.deleteCustomState(\"invalid\")\n          this.deleteCustomState(\"user-invalid\")\n          this.deleteCustomState(\"valid\")\n          this.deleteCustomState(\"user-valid\")\n          return\n        }\n\n        this.deleteCustomState(\"disabled\")\n\n        if (this.validity.valid) {\n          this.deleteCustomState(\"invalid\")\n          this.deleteCustomState(\"user-invalid\")\n          this.addCustomState(\"valid\")\n          this.toggleCustomState(\"user-valid\", this.hasInteracted && this.valueHasChanged)\n        } else {\n          this.deleteCustomState(\"valid\")\n          this.deleteCustomState(\"user-valid\")\n          this.addCustomState(\"invalid\")\n          this.toggleCustomState(\"user-invalid\", this.hasInteracted && this.valueHasChanged)\n        }\n      }\n    }\n  )\n}\n\n", "import { VanillaFormAssociatedMixin } from \"./vanilla-form-associated-mixin.js\"\n\nconst formProperties = Object.freeze({\n  role: {reflect: true},\n  name: {reflect: true},\n  type: {reflect: true},\n  /**\n   * Don't reflect \"disabled\". It breaks the `formDisabledCallback` on formAssociated elements when used with `<fieldset disabled>`.\n   *   https://github.com/whatwg/html/issues/8365\n   */\n  disabled: {type: Boolean},\n  required: {reflect: true, type: Boolean},\n  defaultValue: {attribute: \"value\", reflect: true},\n  valueHasChanged: {type: Boolean, attribute: false, state: true},\n  hasInteracted: {attribute: false, type: Boolean, state: true},\n  formControl: {attribute: false, state: true},\n  value: {attribute: false, state: true},\n})\n\nLitFormAssociatedMixin.formProperties = formProperties\n\n/**\n * An extension of the VanillaFormAssociatedMixin intended for LitElement by providing formProperties and willUpdate() callbacks with the appropriate properties.\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {import(\"./vanilla-form-associated-mixin.js\").FormAssociatedElement} T\n * @param {T} superclass\n */\nexport function LitFormAssociatedMixin(superclass) {\n  const finalClass = class extends VanillaFormAssociatedMixin(superclass) {\n    /**\n      * @param {...any} args\n      */\n    constructor (...args) {\n      super(...args)\n\n      const ctor = /** @type {{properties?: { disabled?: { reflect?: boolean }}}} */ (/** @type {unknown} */ (this.constructor))\n      if (ctor.properties?.disabled?.reflect === true) {\n        console.warn(`The following element has their \"disabled\" property set to reflect.`)\n        console.warn(this)\n        console.warn(\"For further reading: https://github.com/whatwg/html/issues/8365\")\n      }\n    }\n\n\n    /**\n     * @type {import(\"lit\").LitElement[\"willUpdate\"]}\n     */\n    willUpdate (changedProperties) {\n      // @ts-expect-error\n      if (typeof super.willUpdate !== \"function\") {\n        return\n      }\n\n      if (changedProperties.has(\"formControl\")) {\n        this.formControl?.addEventListener(\"focusout\", this.handleInteraction)\n        this.formControl?.addEventListener(\"blur\", this.handleInteraction)\n        this.formControl?.addEventListener(\"click\", this.handleInteraction)\n      }\n\n      if (\n        changedProperties.has(\"formControl\")\n        || changedProperties.has(\"defaultValue\")\n        || changedProperties.has(\"value\")\n      ) {\n        this.setFormValue(this.value, this.value)\n      }\n\n      // @ts-expect-error\n      super.willUpdate(changedProperties)\n    }\n  }\n\n  return /** @type {ReturnType<typeof VanillaFormAssociatedMixin<T>> & typeof finalClass} */ (finalClass)\n}\n\n", "import { TooLongValidator } from \"../validators/too-long-validator.js\"\nimport { TooShortValidator } from \"../validators/too-short-validator.js\"\nimport { LitFormAssociatedMixin } from \"./lit-form-associated-mixin.js\"\n\nLitTextareaMixin.formProperties = Object.freeze(\n  Object.assign(\n    {\n      autocomplete: {},\n      wrap: {},\n      readOnly: {attribute: \"readonly\", type: Boolean, reflect: true},\n      placeholder: {},\n      dirName: {},\n      rows: {type: Number},\n      cols: {type: Number},\n\n      // Validation\n      maxLength: {attribute: \"maxlength\", type: Number},\n      minLength: {attribute: \"minlength\", type: Number},\n    },\n    LitFormAssociatedMixin.formProperties\n  )\n)\n\n/**\n * A mixin for build a `<textarea>` specifically for Lit.\n *\n * @see https://webkit.org/blog/13711/elementinternals-and-form-associated-custom-elements/\n * @template {import(\"./vanilla-form-associated-mixin.js\").FormAssociatedElement} T\n * @param {T} superclass\n */\nexport function LitTextareaMixin(superclass) {\n  // This looks weird, but it's the only way to correctly cast the TextAreaMixin to have a \"typesafe\" value.\n  // from `{value: string | File | FormData | null}` to `{value: string}`\n  /** @type {T & import(\"./types.js\").GConstructable<{defaultValue: string, value: string}>} */\n  // @ts-expect-error\n  const modifiedSuperclass = superclass\n\n  return (\n    /**\n      * @implements {HTMLTextAreaElement}\n      */\n    class extends LitFormAssociatedMixin(modifiedSuperclass) {\n\n      /**\n       * @override\n       * @type {Array<import(\"../types.js\").Validator>}\n       */\n      static get validators () {\n        return [\n          ...super.validators,\n          TooLongValidator(),\n          TooShortValidator(),\n        ]\n      }\n\n      static get properties () {\n        /**\n          * @type {null | import(\"lit\").PropertyValues}\n          */\n        // @ts-expect-error\n        const properties = super.properties\n        if (properties) {\n          return {...LitTextareaMixin.formProperties, ...properties}\n        }\n\n\n        return LitTextareaMixin.formProperties\n      }\n      /**\n        * @param {...any} args\n        */\n      constructor (...args) {\n        super(...args)\n\n        /**\n          * @type {HTMLTextAreaElement[\"autocomplete\"]}\n          */\n        this.autocomplete = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"wrap\"]}\n          */\n        this.wrap = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"value\"]}\n          */\n        this.value = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"defaultValue\"]}\n          */\n        this.defaultValue = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"maxLength\"]}\n          */\n        this.maxLength = -1\n\n        /**\n          * @type {HTMLTextAreaElement[\"minLength\"]}\n          */\n        this.minLength = -1\n\n        /**\n          * @type {HTMLTextAreaElement[\"readOnly\"]}\n          */\n        this.readOnly = false\n\n        /**\n          * @type {HTMLTextAreaElement[\"placeholder\"]}\n          */\n        this.placeholder = \"\"\n\n        /**\n          * @type {HTMLTextAreaElement[\"required\"]}\n          */\n        this.required = false\n\n        /**\n          * @type {HTMLTextAreaElement[\"dirName\"]}\n          */\n        this.dirName = \"\"\n\n        /** @type {HTMLTextAreaElement[\"selectionDirection\"]} */\n        this.selectionDirection = \"forward\"\n\n        /**\n          * @type {number}\n          */\n        this.rows = 2\n\n        /**\n          * @type {number}\n          */\n        this.cols = 20\n      }\n\n      /**\n        * @param {Parameters<HTMLTextAreaElement[\"setSelectionRange\"]>} args\n        */\n      setSelectionRange (...args) {\n        const formControl = this.formControl\n\n        if (formControl && \"selectionRange\" in formControl) {\n          /** @type {HTMLTextAreaElement} */ (/** @type {unknown} */ (formControl)).setSelectionRange(...args)\n        }\n      }\n\n      /**\n        * @param {[replacement: string, start: number, end: number, selectionMode?: SelectionMode] | [replacement: string]} args\n        */\n      setRangeText (...args) {\n        const formControl = this.formControl\n\n        if (formControl && \"setRangeText\" in formControl) {\n          // @ts-expect-error\n          /** @type {HTMLTextAreaElement} */ (/** @type {unknown} */ (formControl)).setRangeText(...args)\n        }\n      }\n\n      /**\n        * @returns {HTMLTextAreaElement[\"textLength\"]}\n        */\n      get textLength () {\n        const formControl = /** @type {HTMLTextAreaElement} */ (this.formControl)\n\n        if (formControl && \"textLength\" in formControl) {\n          return formControl.textLength\n        }\n\n        return 0\n      }\n\n      /**\n        * @returns {HTMLTextAreaElement[\"selectionStart\"]}\n        */\n      get selectionStart () {\n        const formControl = /** @type {HTMLTextAreaElement} */ (this.formControl)\n\n        if (formControl && \"selectionStart\" in formControl) {\n          return formControl.selectionStart\n        }\n\n        return 0\n      }\n\n      /**\n        * @returns {HTMLTextAreaElement[\"selectionStart\"]}\n        */\n      get selectionEnd () {\n        const formControl = /** @type {HTMLTextAreaElement} */ (this.formControl)\n\n        if (formControl && \"selectionEnd\" in formControl) {\n          return formControl.selectionEnd\n        }\n\n        return 0\n      }\n\n      /**\n        * @type {HTMLTextAreaElement[\"select\"]}\n        */\n      select () {\n        const formControl = this.formControl\n\n        if (formControl) {\n          /** @type {HTMLTextAreaElement} */ (formControl).select?.()\n        }\n      }\n    }\n  )\n}\n", "import { css } from \"lit\";\n\nexport const styles = css`\n  [part~=\"base\"] {\n    font-family: Menlo, Monaco, \"Courier New\", monospace;\n    font-size: 1rem;\n    height: 15em;\n    width: 100%;\n    max-width: 100%;\n    max-height: 100%;\n    position: relative;\n    overflow: hidden;\n    resize: both;\n    font-size: normal;\n    font-family: monospace;\n    line-height: 1.5; /* Inherited to child elements */\n    tab-size: 2;\n    caret-color: black;\n    counter-reset: linenumber 0;\n    border: 1px solid gray;\n  }\n\n  /* Include \"pre\" if line numbers are disabled */\n  :host([disable-line-numbers]) [part~=\"textarea\"],\n  [part~=\"textarea\"],\n  light-code::part(line) {\n    padding-inline-start: 8px;\n    padding-inline-end: 8px;\n  }\n\n  [part~=\"textarea\"] {\n    color: transparent;\n    /* color: rgba(255,0,0,0.2); */\n    background-color: transparent;\n    caret-color: inherit;\n    z-index: 1;\n    resize: none;\n    padding: 0;\n\n    /* Dynamically generated based on the size of the  gutter from \"<light-code>\" */\n    padding-inline-start: calc(var(--gutter-width, 40px) + 8px);\n  }\n\n  light-code {\n    pointer-events: none;\n  }\n\n  light-code::part(pre) {\n    border-color: transparent;\n    position: relative;\n  }\n\n  light-code::part(line)::before {\n    content: \"\";\n    line-height: inherit;\n    padding-inline-end: 0px;\n  }\n\n  [part~=\"base\"]:focus-within {\n    border-color: dodgerblue;\n    outline: 2px solid dodgerblue;\n  }\n\n  [part~=\"textarea\"]:focus {\n    outline: transparent;\n  }\n\n  light-code::part(line) {\n    padding-inline-start: 8px;\n  }\n\n  light-code::part(pre),\n  [part~=\"textarea\"],\n  light-code::part(code) {\n    /* I don't love this, but it fixes font size inconsistencies on mobile. The alternative is listen for font-size changes, which is...challenging. */\n    -webkit-text-size-adjust: 100%;\n    -moz-text-size-adjust: 100%;\n    text-size-adjust: 100%;\n\n    font-size: inherit;\n    font-family: inherit;\n    line-height: inherit;\n    tab-size: inherit;\n  }\n\n  [part~=\"textarea\"] {\n    /* this creates line-wrapping. */\n    word-break: break-word;\n    white-space: pre-wrap;\n  }\n\n  :host([wrap=\"hard\"]) [part~=\"textarea\"] {\n    /* This would remove line-wrapping */\n    word-break: break-all;\n    white-space: pre;\n  }\n\n  [part~=\"base\"]:focus-within light-code::part(line-highlight) {\n    background-color: rgba(255, 255, 209, 1);\n  }\n\n  [part~=\"base-editor\"] {\n    position: relative;\n    display: grid;\n    grid-template-columns: minmax(0, 1fr);\n    grid-template-rows: minmax(0, 1fr);\n    max-height: 100%;\n    min-height: 100%;\n  }\n\n  light-code,\n  [part~=\"textarea\"] {\n    grid-area: 1/1/2/2;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    border: none;\n    overflow: auto;\n    border: none;\n  }\n\n  [part~=\"textarea\"]::placeholder {\n    color: rgba(0, 0, 0, 0.5);\n  }\n\n  [part~=\"textarea\"]::selection {\n    color: inherit;\n    background-color: rgba(0, 0, 0, 0.15);\n  }\n`;\n", "export class BaseEvent extends Event {\n  /**\n   * @param {string} name\n   * @param {EventInit} [options={}]\n   */\n  constructor(name, options = {}) {\n    if (options.bubbles == null) options.bubbles = true;\n    if (options.composed == null) options.composed = true;\n    super(name, options);\n  }\n}\n", "// @ts-check\nimport { BaseEvent } from \"../../internal/base-event.js\";\n\nexport class LightResizeEvent extends BaseEvent {\n  /**\n   * @param {\"light-resize\" | Omit<string, \"light-resize\"> & string} [name=\"light-resize\"]\n   * @param {Partial<EventInit & { height: number, width: number }>} [options={}]\n   */\n  constructor(name = \"light-resize\", options = {}) {\n    super(name, options);\n\n    this.height = options.height;\n    this.width = options.width;\n  }\n}\n", "// @ts-check\nimport { html, LitElement } from \"lit\";\nimport { ref } from \"lit/directives/ref.js\";\nimport { LitTextareaMixin } from \"form-associated-helpers/exports/mixins/lit-textarea-mixin.js\";\n\nimport { baseStyles } from \"../../styles/base-styles.js\";\nimport { theme } from \"../../styles/default-theme.styles.js\";\nimport { styles } from \"./light-editor.styles.js\";\n\nimport { LightResizeEvent } from \"../../events/light-resize-event.js\";\n\nimport { dedent } from \"../../../internal/dedent.js\";\nimport { BaseElement } from \"../../../internal/base-element.js\";\nimport { elementsToString } from \"../../../internal/elements-to-strings.js\";\nimport { createPrismInstance } from \"../../../internal/prism-highlight.js\";\n\nimport LightCode from \"../light-code/light-code.js\";\n\nconst newLineRegex = /\\r\\n?|\\n/g;\n\n/**\n * A minimal plain text editor with syntax highlighting, line numbers, and line highlighting.\n *    `<light-editor>` is not intended to replace full solutions like CodeMirror, but it\n *    is a lightweight alternative using a `<pre>` overlaid on top of a `<textarea>`\n *    and a few extra divs to make for an enjoyable text editing experience.\n *\n * @customElement\n * @tagname light-editor\n *\n * @event {Event} light-input - Re-emits the textarea's \"input\" event\n * @event {Event} light-change - Re-emits the textarea's \"change\" event\n * @event {Event} light-selectionchange - Re-emits the textarea's \"selectionchange\" event\n * @event {Event} light-focus - Re-emits the textarea's \"focus\" event\n * @event {Event} light-blur - Re-emits the textarea's \"blur\" event\n * @event {Event} light-resize - Is emitting whenever the editor resizes.\n * @event {Event} light-value-change - Emitted whenever the \"value\" attribute of the editor changes.\n *\n */\nexport default class LightEditor extends LitTextareaMixin(BaseElement) {\n  /**\n   * @override\n   */\n  static baseName = \"light-editor\";\n\n  /**\n   * @override\n   */\n  static dependencies = { \"light-code\": LightCode };\n\n  /**\n   * @override\n   * Without delegatesFocus, we get this fun message:\n   *  \"The invalid form control with name='editor' is not focusable.\"\n   */\n  static shadowRootOptions = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  /**\n   * @override\n   */\n  static styles = [baseStyles, styles, theme];\n\n  /**\n   * @override\n   */\n  static properties = {\n    ...LitTextareaMixin.formProperties,\n    wrap: { reflect: true, state: false },\n    language: { reflect: true },\n    src: {},\n    disableLineNumbers: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"disable-line-numbers\",\n    },\n    preserveWhitespace: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"preserve-whitespace\",\n    },\n    hasFocused: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"data-has-focused\",\n    },\n    currentLineNumber: {\n      attribute: false,\n      state: true,\n      type: Number,\n    },\n    highlighter: {\n      attribute: false,\n      state: true,\n    },\n  };\n\n  constructor() {\n    super();\n\n    /**\n     * The language used for highlighting. Default is \"html\". \"css\" and \"js\" also included by default.\n     * @type {string}\n     */\n    this.language = \"html\";\n\n    /**\n     * The value to set for the text editor\n     * @type {string}\n     */\n    this.value = \"\";\n\n    /**\n     * This is the value attribute. This is used for resetting the form input.\n     * @type {string}\n     */\n    this.defaultValue = \"\";\n\n    /**\n     * The underlying textarea\n     * @type {null | HTMLTextAreaElement}\n     */\n    this.textarea = null;\n\n    /**\n     * Points to a remote file source that should be accessible via `fetch()`\n     * @type {string | null}\n     */\n    this.src = null;\n\n    /**\n     * @property\n     * @type {\"soft\" | \"hard\"}\n     * If `wrap=\"soft\"`, lines will wrap when they reach the edge of their container. If `wrap=\"hard\"`, lines will not wrap instead all the user to scroll horizontally to see more code.\n     */\n    this.wrap = \"soft\";\n\n    /**\n     * Whether to strip whitespace before first character, and after the last character.\n     * @type {boolean}\n     */\n    this.preserveWhitespace = false;\n\n    /**\n     * @type {boolean}\n     */\n    this.disableLineNumbers = false;\n\n    /**\n     * Points to an instance of Prism from \"prism-esm\" for adjusting highlighting, adding plugins, etc.\n     * @type {ReturnType<typeof createPrismInstance>}\n     */\n    this.highlighter = createPrismInstance();\n\n    /**\n     * @type {number}\n     */\n    this.currentLineNumber = 1;\n  }\n\n  /**\n   * @override\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    this.value = this.getAttribute(\"value\") || \"\";\n    this.defaultValue = this.getAttribute(\"value\") || \"\";\n\n    if (\n      this.value === this.getAttribute(\"value\") &&\n      this.preserveWhitespace !== true\n    ) {\n      // Remove only lines that are blank with spaces that are blank. trim() removes preceding white-space for the line with characters.\n      // https://stackoverflow.com/questions/14572413/remove-line-breaks-from-start-and-end-of-string#comment104290392_14572494\n      this.value = dedent(\n        this.value.replace(/(^\\s*(?!.+)\\n+)|(\\n+\\s+(?!.+)$)/g, \"\"),\n      ).trim();\n    }\n  }\n\n  /**\n   * @override\n   * @param {import(\"lit\").PropertyValues<typeof this>} changedProperties\n   */\n  willUpdate(changedProperties) {\n    if (changedProperties.has(\"value\")) {\n      // Emit events on value updates\n      this.dispatchEvent(\n        new Event(\"light-value-change\", { bubbles: true, composed: true }),\n      );\n\n      this.dispatchEvent(\n        new Event(\"change\", { bubbles: true, composed: true }),\n      );\n    }\n\n    if (changedProperties.has(\"src\") && this.src) {\n      fetch(this.src).then(async (response) => {\n        let finalValue = await response.text();\n\n        if (this.preserveWhitespace !== true) {\n          finalValue = dedent(\n            finalValue.replace(/(^\\s*(?!.+)\\n+)|(\\n+\\s+(?!.+)$)/g, \"\"),\n          ).trim();\n        }\n\n        return finalValue;\n      });\n    }\n\n    super.willUpdate(changedProperties);\n  }\n\n  /**\n   * @override\n   */\n  click() {\n    if (this.textarea) {\n      this.textarea.click();\n    } else {\n      this.click();\n    }\n  }\n\n  /**\n   * @override\n   * @param {FocusOptions} [options]\n   */\n  focus(options) {\n    if (this.textarea) {\n      this.textarea.focus(options);\n    } else {\n      this.focus(options);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  __setGutterWidth() {\n    const gutterWidth = /** @type {undefined | null | HTMLElement} */ (\n      this.shadowRoot\n        ?.querySelector(\"light-code\")\n        ?.shadowRoot?.querySelector(\"[part~='gutter']\")\n    )?.offsetWidth;\n\n    if (gutterWidth) {\n      this.style.setProperty(\"--gutter-width\", `${gutterWidth}px`);\n      return;\n    }\n\n    this.style.removeProperty(\"--gutter-width\");\n  }\n\n  /**\n   * @override\n   */\n  render() {\n    const language = this.language;\n    this.syncScroll();\n\n    setTimeout(async () => {\n      await this.updateComplete;\n      this.__setGutterWidth();\n    });\n\n    return html`\n      <div part=\"base\">\n        <!-- This is where the fancy syntax highlighting comes in -->\n        <div part=\"base-editor\">\n          <!-- This bad boy is for measuring cursors -->\n          <pre\n            part=\"pre\"\n            aria-hidden=\"true\"\n            style=\"\n              position: fixed;\n              top: 0;\n              left: 0;\n              pointer-events: none;\n              visibility: hidden;\n            \"\n          ><code part=\"code\"><span id=\"before-caret\"></span><span id=\"caret\">.</span><span id=\"after-caret\">.</span></code></pre>\n\n          <light-code\n            tabindex=\"-1\"\n            .language=${this.language}\n            .code=${this.value}\n            .wrap=${this.wrap}\n            .highlighter=${this.highlighter}\n            .disableLineNumbers=${this.disableLineNumbers}\n            .preserveWhitespace=${this.preserveWhitespace}\n            .highlightLines=${`{${this.hasFocused ? this.currentLineNumber : \"\"}}`}\n            @focus=${() => {\n              this.textarea?.focus();\n            }}\n            @touchstart=${(/** @type {Event} */ e) => {\n              // Don't let a user focus on this area.\n              this.textarea?.focus();\n            }}\n            @click=${(/** @type {Event} */ e) => {\n              // Don't let a user focus on this area.\n              this.textarea?.focus();\n            }}\n          ></light-code>\n\n          <!-- IMPORTANT! There must be no white-space above. -->\n          <textarea\n            id=\"textarea-${language}\"\n            ${ref(this.textareaChanged)}\n            data-code-lang=${language}\n            part=\"textarea textarea-${language}\"\n            spellcheck=\"false\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            minlength=${this.minLength}\n            maxlength=${this.maxLength}\n            translate=\"no\"\n            .defaultValue=${this.defaultValue}\n            .value=${this.value}\n            ?disabled=${this.disabled}\n            ?required=${this.required}\n            placeholder=${this.placeholder}\n            @keyup=${this.keyupHandler}\n            @keydown=${this.keydownHandler}\n            @focus=${() => {\n              this.hasFocused = true;\n              this.syncScroll();\n              this.setCurrentLineHighlight();\n              this.dispatchEvent(\n                new Event(\"light-focus\", { bubbles: true, composed: true }),\n              );\n            }}\n            @blur=${() => {\n              this.setAttribute(\"data-has-interacted\", \"\");\n              this.syncScroll();\n              this.setCurrentLineHighlight();\n              this.dispatchEvent(\n                new Event(\"light-blur\", { bubbles: true, composed: true }),\n              );\n            }}\n            @selectionchange=${\n              /** @param {Event} e */ (e) => {\n                this.syncScroll();\n                this.setCurrentLineHighlight();\n                this.dispatchEvent(\n                  new Event(\"light-selectionchange\", {\n                    bubbles: true,\n                    composed: true,\n                  }),\n                );\n              }\n            }\n            @click=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @touchstart=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @touchend=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @pointerdown=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @pointerup=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @input=${\n              /** @param {Event} e */ (e) => {\n                this.value = /** @type {HTMLTextAreaElement} */ (\n                  e.currentTarget\n                ).value;\n                this.setCurrentLineHighlight();\n                this.dispatchEvent(\n                  new Event(\"light-input\", { bubbles: true, composed: true }),\n                );\n                this.dispatchEvent(\n                  new Event(\"input\", { bubbles: true, composed: true }),\n                );\n                this.syncScroll();\n              }\n            }\n            @change=${\n              /** @param {Event} e */ (e) => {\n                this.value = /** @type {HTMLTextAreaElement} */ (\n                  e.currentTarget\n                ).value;\n                this.setCurrentLineHighlight();\n                this.syncScroll();\n              }\n            }\n            @scroll=${\n              /** @param {Event} e */ (e) => {\n                this.setCurrentLineHighlight();\n                this.syncScroll();\n              }\n            }\n          ></textarea>\n        </div>\n        <!-- base-editor -->\n      </div>\n      <!-- base -->\n\n      <!-- Hidden slot for holding content -->\n      <slot hidden @slotchange=${this.handleSlotChangeEvent}></slot>\n    `;\n  }\n\n  /**\n   * @ignore\n   * @param {ResizeObserverEntry[]} entries\n   */\n  handleTextAreaResize(entries) {\n    const { target } = entries[0];\n    const { left, right, top, bottom } = entries[0].contentRect;\n    const width = left + right;\n    const height = top + bottom;\n\n    /**\n     * Fires whenever the editor resizes, usually due to zoom in / out\n     */\n    this.dispatchEvent(new LightResizeEvent(\"light-resize\", { height, width }));\n    this.syncScroll();\n  }\n\n  /**\n   * @override\n   * @param {import(\"lit\").PropertyValues<this>} changedProperties\n   */\n  updated(changedProperties) {\n    super.updated(changedProperties);\n\n    this.syncScroll();\n    setTimeout(() => this.setCurrentLineHighlight());\n  }\n\n  /**\n   * Syncs the `<light-code>` element scroll position to the same as the `<textarea>`\n   * @param {boolean} [syncCaret=false] - Whether or not to sync the caret. This is generally reserved for right / left arrow keys because the gutter is `position: sticky;`.\n   * @internal\n   */\n  syncScroll(syncCaret = false) {\n    // TODO: There's probably a lot of caching we can do here to reduce recomputes.\n    /**\n     * @type {undefined | null | HTMLTextAreaElement}\n     */\n    const textarea = this.textarea;\n\n    if (textarea == null) return;\n\n    const lightCode = this.shadowRoot?.querySelector(\"light-code\");\n    const code = lightCode?.shadowRoot?.querySelector(\"code\");\n\n    if (syncCaret) {\n      const { top, left } = this.getCaretPosition();\n      // textarea.scrollTop = top\n      if (left < 60) {\n        textarea.scrollLeft = Math.min(left, textarea.scrollLeft);\n      }\n    }\n\n    if (lightCode) {\n      lightCode.scrollTop = textarea.scrollTop;\n    }\n\n    if (code) {\n      code.scrollLeft = textarea.scrollLeft;\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {Element | undefined} element\n   */\n  textareaChanged(element) {\n    if (!(element instanceof HTMLTextAreaElement)) {\n      return;\n    }\n\n    const textarea = element;\n    this.textarea = textarea;\n    this.formControl = textarea;\n\n    this.textareaResizeObserver = new ResizeObserver((entries) =>\n      this.handleTextAreaResize(entries),\n    );\n    this.textareaResizeObserver.observe(textarea);\n  }\n\n  /**\n   * @ignore\n   * @param {Event} e\n   */\n  handleSlotChangeEvent(e) {\n    // @TODO: Attach mutations observers to update value.\n    /**\n     * @type {HTMLSlotElement}\n     */\n    // @ts-expect-error\n    const slot = e.target;\n\n    const templates = slot.assignedElements({ flatten: true });\n\n    // We only unescape when passed into templates.\n    let code = this.unescapeTags(elementsToString(...templates));\n\n    if (!this.preserveWhitespace) {\n      code = dedent(code.trim());\n    }\n\n    if (code) {\n      this.value = code;\n      this.defaultValue = code;\n      setTimeout(() => this.textarea?.setSelectionRange(0, 0));\n      this.dispatchEvent(\n        new Event(\"light-input\", { bubbles: true, composed: true }),\n      );\n      this.dispatchEvent(\n        new Event(\"light-change\", { bubbles: true, composed: true }),\n      );\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {KeyboardEvent} evt\n   */\n  keyupHandler(evt) {\n    this.setCurrentLineHighlight();\n    // setTimeout is needed for Safari which appears to be \"slow\" to update selection APIs.\n    setTimeout(() => this.setCurrentLineHighlight());\n  }\n\n  /**\n   * @ignore\n   * @param {KeyboardEvent} evt\n   */\n  keydownHandler(evt) {\n    this.setCurrentLineHighlight();\n    // setTimeout is needed for Safari which appears to be \"slow\" to update selection APIs.\n    setTimeout(() => this.setCurrentLineHighlight());\n    this.syncScroll();\n\n    if (evt.key.startsWith(\"Arrow\") || evt.key === \"Backspace\") {\n      this.syncScroll(true);\n    }\n\n    // Let's not trap focus. For now.\n    // if ('Tab' === evt.key) {\n    //   evt.preventDefault()\n    //   target.setRangeText('\\t', target.selectionStart, target.selectionEnd, 'end')\n    //   this.value = target.value\n    //   return\n    // }\n  }\n\n  getCaretPosition() {\n    /* Inspired by https://github.com/component/textarea-caret-position */\n    const beforeCaret = this.shadowRoot?.getElementById(\"before-caret\");\n    const afterCaret = this.shadowRoot?.getElementById(\"after-caret\");\n    const caret = this.shadowRoot?.getElementById(\"caret\");\n    const textarea = this.textarea;\n\n    const fallback = { top: 0, left: 0 };\n\n    if (!beforeCaret) {\n      return fallback;\n    }\n    if (!afterCaret) {\n      return fallback;\n    }\n    if (!caret) {\n      return fallback;\n    }\n    if (!textarea) {\n      return fallback;\n    }\n\n    if (textarea.selectionStart !== textarea.selectionEnd) {\n      return fallback;\n    }\n\n    beforeCaret.textContent = \"\";\n\n    const textLines = this.getLinesToSelectionStart();\n\n    if (!textLines) {\n      return fallback;\n    }\n\n    const currentLineNumber = textLines.length - 1;\n    const beforeCaretText = textLines[currentLineNumber].substring(\n      0,\n      textarea.selectionStart,\n    );\n    beforeCaret.textContent = beforeCaretText;\n\n    return {\n      top: afterCaret.offsetTop - textarea.scrollTop,\n      left: afterCaret.offsetLeft - textarea.scrollLeft,\n    };\n  }\n\n  setCurrentLineHighlight() {\n    const currentLineNumber = this.getCurrentLineNumber();\n\n    if (currentLineNumber != null) {\n      this.currentLineNumber = currentLineNumber + 1;\n    }\n  }\n\n  getLinesToSelectionStart() {\n    const textArea = this.textarea;\n\n    if (!textArea) return;\n\n    const textLines = textArea.value\n      .substring(0, textArea.selectionStart)\n      .split(newLineRegex);\n\n    return textLines;\n  }\n\n  getCurrentLineNumber() {\n    const textLines = this.getLinesToSelectionStart();\n\n    if (!textLines) {\n      return 0;\n    }\n\n    const currentLineNumber = textLines.length - 1;\n    // const currentColumnIndex = textLines[textLines.length-1].length;\n    // console.log(\"Current Line Number \"+ currentLineNumber+\" Current Column Index \"+currentColumnIndex );\n\n    return currentLineNumber;\n  }\n\n  /**\n   * @ignore\n   * @param {string} text\n   */\n  // This gets tricky. We could do this, but it may be unexpected...\n  unescapeTags(text) {\n    // Replace usages of `&lt;/script>` with `</script>`. Match against\n    return text.replaceAll(/&lt;\\/([\\w\\d\\.-_]+)>/g, \"</$1>\");\n  }\n\n  /**\n   * @ignore\n   * Highlighters strip newlines. But you can see new lines in <textarea>, this fixes that.\n   * @param {string} text\n   */\n  injectNewLine(text) {\n    // Handle final newlines (see article)\n    if (text === \"\" || text[text.length - 1] === \"\\n\") {\n      // If the last character is a newline character\n      text += \" \"; // Add a placeholder space character to the final line\n    }\n\n    return text;\n  }\n}\n"],
  "mappings": "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",
  "names": ["TooLongValidator", "obj", "_hostElement", "maxLength", "stringLength", "element", "validity", "value", "TooShortValidator", "obj", "_hostElement", "minLength", "stringLength", "element", "validity", "value", "ValueMissingValidator", "obj", "element", "validity", "CustomStatesMixin", "superclass", "state", "bool", "FormAssociatedMixin", "superclass", "_a", "args", "__publicField", "isDisabled", "el", "VanillaFormAssociatedMixin", "superclass", "CustomStatesMixin", "FormAssociatedMixin", "args", "__publicField", "e", "parentAttrs", "validator", "attr", "ValueMissingValidator", "staticValidators", "validators", "message", "name", "oldVal", "newVal", "state", "reason", "params", "flags", "anchor", "formControl", "finalMessage", "isValid", "invalidKeys", "str", "formProperties", "LitFormAssociatedMixin", "superclass", "VanillaFormAssociatedMixin", "args", "changedProperties", "LitTextareaMixin", "LitFormAssociatedMixin", "superclass", "modifiedSuperclass", "TooLongValidator", "TooShortValidator", "properties", "args", "formControl", "styles", "i", "BaseEvent", "name", "options", "LightResizeEvent", "BaseEvent", "name", "options", "newLineRegex", "LightEditor", "LitTextareaMixin", "BaseElement", "createPrismInstance", "dedent", "changedProperties", "response", "finalValue", "options", "gutterWidth", "language", "ke", "e", "Kt", "entries", "target", "left", "right", "top", "bottom", "width", "height", "LightResizeEvent", "syncCaret", "textarea", "lightCode", "code", "element", "templates", "elementsToString", "evt", "beforeCaret", "afterCaret", "caret", "fallback", "textLines", "currentLineNumber", "beforeCaretText", "textArea", "text", "__publicField", "LightCode", "h", "baseStyles", "styles", "theme"]
}
